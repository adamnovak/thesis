\chapter{Towards a Human Genome Variation Map}

\newcommand{\vg}{\texttt{vg}\xspace}

\section{Introduction}

In Chapter~\ref{ch:bakeoff}, it was demonstrated that the use of graph-based genomic references can result in improved variant calling performance over traditional linear references, especially with respect to the genotyping of previously-reported insertions and deletions. However, the graph references in that study that produced the most accurate variant calls were derived from the 1000 Genomes Project's main variant call files \cite{10002015global}, and allowed the detection of only relatively short indels, under about 50~bp (Fig.~\ref{fig:bakeoff:refnonref} (C)). Compared to the approximately 300~bp length of a single Alu repeat insertion \cite{weiner1980abundant}, this is inadequate for characterizing genomic variation.

Moreover, when compared not against existing Illumina-based variant calls but against PacBio-based assembly data, variant calling performed with ``Cactus''-based graphs, produced from the alignment of long ``alternative loci'' sequences, was found to be more accurate than variant calling performed against the 1000 Genomes-derived graphs, in terms of how well the resulting view of a pooled ``synthetic diploid'' genome agreed with separate haploid assembly data (Fig.~\ref{fig:bakeoff:calling} (B)). Cactus-based graphs were also shown to allow the detection of longer insertions and deletions than the 1000 Genomes-based graphs (Fig.~\ref{fig:bakeoff:refnonref} (C)). Overall, Cactus-based graphs have some important advantages that 1000 Genomes-based graphs lack.

In order to construct a versatile graph-based reference that will serve as a community resource for read mapping and variant calling, it is desirable to combine the best aspects of these two types of graph. Additionally, as the bake-off project of Chapter~\ref{ch:bakeoff} worked only on regions up to a few megabases in size, it is desirable to demonstrate the effectiveness of graph-based methods at larger scales, where qualities like the ability to resolve mappings between ambiguous regions, and the abbility to effectively use paired-end information, are more critical.

In this chapter, we present a method to create graph references combining the best qualities of 1000 Genomes-based and Cactus-based graphs, and validate these graphs on the scale of a chromosome. We also present a complete whole-genome graph of this type, as an artifact for further evaluation. 

\section{Methods}

In order to combine a Cactus-based graph with a 1000 Genomes-based graph, we implemented a new subcommand in the \vg variation graph toolkit \cite{garrison2016vg}. The new tool, \texttt{vg add}, augments an existing graph by instering variants from a VCF file. It works by extracting local haplotypes around each variant that are locally consistent with the phased samples in the VCF file, and then aligning them to the relevant region of the graph, as determined by tracing an embedded primary reference path in the graph. For particularly large insertions and deletions, where a complete local alignment would be impractical, the ends of the variant are aligned, and the resulting alignments are stitched together to describe the actual variant.

The vg add tool, along with a Toil-based orchestration script \cite{vivian2017toil}, were used to combine variation information from three sources. The base level graph was obtained by using Cactus \cite{paten2011cactus2}, by aligning together the chromosome 22 primary sequence and the chromosome 22 alt and ``random'' sequences from GRCh38.
% TODO: What patch level did Joel use?

On top of this graph, \texttt{vg add} was used to add in variants from the 1000 Genomes Phase 3 GRCh38 lifted-over VCF files, available from \url{ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/release/20130502/supporting/GRCh38_positions/}. Notably, these variant files as distributed by the 1000 Genomes Project are not valid; variants lifted over to the reverse strand of GRCh38 are marked as marked with a \texttt{MATCHED\_REV} tag in the \texttt{INFO} field but left in their GRCh37 orientations, and needed to be reverse-complemented using a script so that the \texttt{REF} field contents will match the actual reference sequence at the variant's location.

% TODO: what source data and processing script did Charlie use?
The \texttt{vg add} tool was also used to add structural variants. Since the structural variants in GRCh38 coordinates, originally obtained from \url{ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/phase3/integrated_sv_map/supporting/GRCh38_positions/}, were described using a complex combination of \texttt{INFO} tags, additional tables, and references to difficult-to-locate external sequence database records, the files had to be preprocessed in order for \texttt{vg add} to be able to parse them. All variant alt information was moved into a fully realized concrete sequence in each variant record's \texttt{ALT} column, and the reference sequences, even for very long deletions, were placed in each variant record's \texttt{REF} column. All symbolic allele references and target site duplication sequences were resolved. For mobile element insertions, the original VCF specified the presence, but not the exact length, of a poly-A tail; in these cases, several duplicate variant records were created, with poly-A tail lengths of 10, 25, and 50 bases. This approach was selected in hopes of providing a mapping target sufficient to collect reads showing the correct poly-A tail length, which could then potentially be determined through graph-based variant calling.

Once fully constructed, the resulting graph was indexed for alignment using \vg, producing XG and GCSA2 indexes. The graph was subjected to two alignment-based evaluations.

The first evaluation was a variant of the assembly realignment evaluation from Chapter~\ref{ch:bakeoff}. A synthetic diploid sample was created from the CHM1 and CHM13 hyatidiform mole samples aligned to GRCh38 (it was actually the same sample used in Chapter~\ref{ch:bakeoff}). Form this sample, the reads aligned to chromosome 22 were collected. %TODO: need to grab related reads too!
These reads were aligned to and used for variant calling against the graph under test. However, instead of calling variants to VCF, we created an improved version of the \texttt{vg call} variant caller capable of outputting variants in the form of Protobuf-serialized \texttt{Locus} objects, which describe a genotype call among a set of arbitrarily-defined alternative paths in an augmented graph. Using this ability, we produced \texttt{Locus} objects with calls for the ultrabubbles in the augmented graph (including both parent and nested child ultrabubbles), and \texttt{Locus} objects asserting the presence of all edges that had sufficient coverage but which were not part of an ultrabubble \cite{paten2017superbubbles}. Finally, as in Chapter~\ref{ch:bakeoff}, the augmented graph was subsetted, this time by eliminating all nodes and edges not called as present in some \texttt{Locus}, to create a sample graph. This sample graph was indexed and used to align up-to-1000-bp fragments of the CHM1 and CHM13 assembly contigs that were determined, using BWA's \texttt{bwasw} mode and a threshold score, to align well to chromosome 22 of the GRCh38 reference. The quality of the sample graph as a representation of these aligned assembly fragments was then measured.

The second evaluation, by contrast, was a truth set VCF-based measurement of the accuracy of structural variant calls. Reads aligned to GRCh38 were obtained for five samples: NA12878, NA12889, and NA12890 from the Illumina Platinum Genomes dataset, and HG00513 and HG00732 from the 1000 Genomes High Coverage dataset. From each file of aligned reads, read pairs where either member mapped to chromosome 22 or any of its ``random'' or ``alt'' contigs were collected. These reads were then mapped to the graph under test, and variant calling for each sample was performed, using the default \texttt{vg call} parameters and an additonal \texttt{--max-dp-multiple 2.5} setting. Variant calls in VCF format were obtained. For each sample, the called VCF was compared against the GRCh38 structural variant files that were used for preparing the graph. Recall was computed by considering each unique variant position in the truth VCF for which an alternate allele was specified in an unfiltered variant for the sample in question, and treating it as recalled if the variant calls for the sample in question contained an unfiltered variant with a length change of 25~bp or more with a position within 25~bp of the truth variant for which an alternate allele was called. Because the truth set VCF used was not believed or warranted to be complete, precision was computed manually, by randomly sampling a certain number of calls for variants with length changes of 25~bp or more with calls of alternate alleles, and manually classifying each selected positive call as true or false, by looking at the original input reads and the truth VCF at the variant's location on the UCSC genome browser.

\section{Results}

For the second, VCF-based evaluation, the precision statistics for NA12878 are visible in Table~\ref{tbl:svprecision}, while the recall results for all samples are visible in Table~\ref{tbl:svrecall}. %TODO: replace old NA12878 stats with stats for everyone.
In NA12878, a precision of 8 out of 10, or 0.8, was observed, while, summing possible and recalled variants across all samples, an overall recall of 106 of 151, or 0.702, was observed. Together, these produce an F1 score of 0.75.

% TODO: This is before the vg add fix and needs to be replaced with the run from 2017-05-09
\begin{table}
\centering
\begin{tabular} {l|c|c|c|c|c}
\textbf{Position} & \textbf{Type} & \textbf{Length (bp)} & \textbf{In 1KG} & \textbf{In Reads} & \textbf{Verdict} \\
\hline
19798198 & Insertion & 29 & & & False \\
49435233 & Deletion & 28 & & \textbullet & True \\
17616766 & Deletion & 310 & \textbullet & \textbullet & True \\
49713384 & Deletion & 39 & & \textbullet & True \\
42990018 & Deletion & 38 & & \textbullet & True \\
41378674 & Deletion & 1684 & & & False \\
39195776 & Deletion & 28 & & \textbullet & True \\
17289460 & Deletion & 8758 & \textbullet & \textbullet & True \\
42219368 & Insertion & 29 & & \textbullet & True \\
48948505 & Insertion & 33 & & \textbullet & True
\end{tabular}
\caption[Structural variant precision]{Precision estimation from 10 randomly-sampled calls of variants inducing length changes of 25~bp or more in NA12878 on chromosome~22. Variants called by VG agains the chromosome 22 HGVM prototype were manually assessed for corespondence to 1000 Genomes structural variant set variants, and for support in the Illumina Platinum Pedigree reads for the appropriate sample, using the UCSC Genome Browser. Variants supported either by the 1000 Genomes set or by the reads were designated as true variants, while other variants were designated as false variants. Overall, 8~of 10~variants examined were designated as true, producing a precision estimate of 0.8.}
\label{tbl:svprecision}
\end{table}

\begin{table}
\centering
\begin{tabular} {l|c|c|c|c|c}
\textbf{Sample} & \textbf{Total SVs} & \textbf{Called SVs} & \textbf{Recall} \\
\hline
HG00513 & 29 & 19 & 0.66 \\
HG00732 & 31 & 20 & 0.65 \\
NA12878 & 30 & 21 & 0.70 \\
NA12889 & 29 & 21 & 0.72 \\
NA12890 & 32 & 25 & 0.78
\end{tabular}
\caption[Structural variant recall]{Recall statistics for structural variants called by \texttt{vg} in five samples, with the structural variant VCF used to construct the graph used as the truth set.}
\label{tbl:svrecall}
\end{table}

\section{Conclusion}

\section{Acknowledgements}

The author would like to thank Joel Armstrong for performing Cactus alignments used in this work. The author would also like to thank Charles Markello for preparing flat structural variant VCF files. The author would like to thank Glenn Hickey for preparing the synthetic diploid sample used in the evaluations.

% Towards a Human Genome Variation Map
    % Intro
        % So in the bake-off paper, aka last chapter, we showed that it's possible to get improved variant calling performance with a graph reference
        % But we had these references with only short variants in them that did really well
        % Can we improve performance by bringing in more info about long variants and alt loci?
    % Methods
        % We developed a method to add variants from a VCF into a graph
            % It's based on all these realignment heuristics to try and get good performance/not crash
        % We also improve the assembly realignment evaluation from the paper
            % By not going through VCF and instead infering presence/absence of nodes and edges from nested, ploidy-aware genotype calls
        % We developed an HGVM building and evaluating tool which is here on Github/pip
    % Results (still preliminary)
        % We built a graph for chr22 on 3/23/17
        
            % TMPDIR=/hive/users/anovak/tmp time build-hgvm ./tree2 chr22_build --base_vg_url file:`pwd`/sourceGraphs/human22.only.chopped.vg --vcf_contig "chr22" --vcfs_url file:`pwd`/../forward_vcfs --vcfs_url file:/cluster/home/charles/SV_HGVM_research/eighth_draft_GRCh38_bks_only_polALengths_chrs --add_chr --sample_fastq_url file:`pwd`/../mole_bams/syndip-chr22-fastq.R1.fastq --sample_fastq_url file:`pwd`/../mole_bams/syndip-chr22-fastq.R2.fastq --eval_sequences_url file:`pwd`/to_realign.seqs --dump_hgvm ./chr22_build_dump --logInfo --realTimeLogging | tee log.txt
            
        % On chr22 (chr21?) we see improved variant calling performance, as measured by the realignment eval, between calling on the graph and calling on a linear control graph
            % If time permits, we can do a leave-one-out on the data sources and see if they all contribute positively
        % On chr22 (chr21?) we see improved SV calling performance, as measured by recall against the 1kg VCF for NA12878, relative to calling against a linear control
            % TODO: implement that linear control
            % Again, we can try controls from other subsets of the input data (just alts, just 1kg point variants, etc.)
                % And we can move the "what's an SV" threshold around to exclude the point variants if there's crosstalk
        % For the whole genome, here is a cool way (IPFS? DAT?) to retrieve a graph build with index
    % Conclusions
        % We are indeed barking up the right tree with graph-based references
        % More work is needed
            % To validate the whole genome build
            % To pull in more data
            % To polish the tools
            % To establish best practices
